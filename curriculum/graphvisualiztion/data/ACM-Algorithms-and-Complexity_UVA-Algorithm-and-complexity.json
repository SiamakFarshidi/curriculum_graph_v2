{"nodes": [{"id": "1", "label": "Algorithms and Complexity", "group": "1", "shape": "circle", "description": "Algorithms and Complexity: "}, {"id": "1.1", "label": "Algorithmic Strategies", "group": "1", "shape": "box", "description": "Algorithmic Strategies: covers various approaches and techniques used to design and analyze algorithms"}, {"id": "1.1.14", "label": "Recursive", "group": "1", "shape": "ellipse", "description": "Recursive: Algorithms that solve problems by calling themselves with smaller input instances until a base case is reached."}, {"id": "1.1.2", "label": "Backtracking", "group": "1", "shape": "ellipse", "description": "Backtracking: A systematic method for exploring all possible solutions to a problem by incrementally building candidates and backtracking when a dead-end is reached."}, {"id": "1.1.6", "label": "Decrease-and-Conquer", "group": "1", "shape": "ellipse", "description": "Decrease-and-Conquer: Algorithms that reduce a problem instance to a smaller instance of the same problem, solve the smaller instance, and then use the solution to solve the original problem."}, {"id": "1.1.7", "label": "Divide-and-Conquer", "group": "1", "shape": "ellipse", "description": "Divide-and-Conquer: A problem-solving technique that breaks a problem into smaller subproblems, solves the subproblems recursively, and then combines the solutions to solve the original problem."}, {"id": "1.1.8", "label": "Dynamic Programming", "group": "1", "shape": "ellipse", "description": "Dynamic Programming: A method for solving optimization problems by breaking them down into simpler subproblems and storing the solutions to avoid redundant calculations."}, {"id": "1.1.9", "label": "Greedy", "group": "1", "shape": "ellipse", "description": "Greedy: An algorithmic paradigm that makes locally optimal choices at each step with the hope of finding a global optimum solution."}, {"id": "1.2", "label": "Complexity Analysis", "group": "1", "shape": "box", "description": "Complexity Analysis: evaluating algorithms' performance in terms of time and space efficiency"}, {"id": "1.2.3", "label": "Iterative and recursive algorithm analysis", "group": "1", "shape": "ellipse", "description": "Iterative and recursive algorithm analysis: examining algorithms' time and space complexities and comparing their performance under different scenarios"}, {"id": "1.3", "label": "Fundamental Data Structures and Algorithms", "group": "1", "shape": "box", "description": "Fundamental Data Structures and Algorithms: including arrays, linked lists, trees, sorting and searching algorithms"}, {"id": "1.3.13", "label": "Trees: Binary, n-ary, Search", "group": "1", "shape": "ellipse", "description": "Trees: Binary, n-ary, Search: Trees are hierarchical data structures composed of nodes"}, {"id": "1.3.13.3", "label": "Huffman Coding", "group": "1", "shape": "square", "description": "Huffman Coding: A data compression algorithm used to encode data more efficiently by assigning variable-length codes to input characters"}, {"id": "1.3.14", "label": "Sorting Algorithms:", "group": "1", "shape": "ellipse", "description": "Sorting Algorithms:: Includes various techniques such as Selection Sort, Insertion Sort, Quicksort, Merge Sort, Heap Sort, Bucket Sort, Radix Sort, etc."}, {"id": "1.3.14.2", "label": "O(n log n) Sorting", "group": "1", "shape": "square", "description": "O(n log n) Sorting: Quicksort, Merge Sort, and Heap Sort, with a time complexity of O(n log n)."}, {"id": "1.3.15", "label": "Basic Linear Algebra", "group": "1", "shape": "ellipse", "description": "Basic Linear Algebra: Fundamental concepts such as vectors, matrices, operations like addition, subtraction, scalar multiplication, dot product, cross product, determinants"}, {"id": "1.3.15.1", "label": "Matrix Multiplication", "group": "1", "shape": "square", "description": "Matrix Multiplication: Strassen\u2019s Matrix Multiplication"}, {"id": "1.3.2", "label": "Arrays: single and multi-dimensional", "group": "1", "shape": "ellipse", "description": "Arrays: single and multi-dimensional: Basic data structures used for storing elements"}, {"id": "1.3.2.1", "label": "Linear and Binary Search", "group": "1", "shape": "square", "description": "Linear and Binary Search: linear search iterates through elements one by one, and binary search halves the search space with each comparison in a sorted array."}, {"id": "1.3.20", "label": "Linear Programming", "group": "1", "shape": "ellipse", "description": "Linear Programming: e.g., Simplex algorithm; Optimization method for maximizing or minimizing a linear objective function subject to linear equality and inequality constraints"}, {"id": "1.3.5", "label": "Graph Algorithms", "group": "1", "shape": "ellipse", "description": "Graph Algorithms: a set of techniques used to analyze and manipulate graphs"}, {"id": "1.3.5.4", "label": "Minimal Spanning Tree", "group": "1", "shape": "square", "description": "Minimal Spanning Tree: Prim\u2019s and Kruskal\u2019s algorithms"}, {"id": "17", "label": "Algorithm and Complexity", "group": "17", "shape": "circle", "description": "Algorithm and Complexity: "}, {"id": "17.1", "label": "Algorithmic Techniques", "group": "17", "shape": "box", "description": "Algorithmic Techniques: "}, {"id": "17.1.1", "label": "Recursion", "group": "17", "shape": "ellipse", "description": "Recursion: A technique where a function calls itself in order to solve smaller instances of the same problem."}, {"id": "17.1.1.1", "label": "Divide and Conquer", "group": "17", "shape": "square", "description": "Divide and Conquer: Divides a problem into smaller subproblems, solves each subproblem independently, and then combines the solutions."}, {"id": "17.1.1.1.1", "label": "Binary search", "group": "17", "shape": "diamond", "description": "Binary search: An efficient search algorithm for finding a target value within a sorted array by repeatedly dividing the search interval in half."}, {"id": "17.1.1.1.3", "label": "Quicksort", "group": "17", "shape": "diamond", "description": "Quicksort: A sorting algorithm that uses the divide and conquer strategy by partitioning the array into smaller subarrays based on a pivot element and recursively sorting each subarray."}, {"id": "17.1.1.1.4", "label": "Matrix multiplication", "group": "17", "shape": "diamond", "description": "Matrix multiplication: A mathematical operation that computes the product of two matrices."}, {"id": "17.1.1.2", "label": "Backtracking", "group": "17", "shape": "square", "description": "Backtracking: A technique for systematically searching through all possible solutions to find the optimal one, often used in constraint satisfaction problems."}, {"id": "17.1.1.2.2", "label": "Recursive algorithm", "group": "17", "shape": "diamond", "description": "Recursive algorithm: An algorithm that solves a problem by solving smaller instances of the same problem."}, {"id": "17.1.2", "label": "Dynamic Programming", "group": "17", "shape": "ellipse", "description": "Dynamic Programming: A technique used to solve problems by breaking them down into smaller overlapping subproblems and solving each subproblem only once"}, {"id": "17.1.3", "label": "Greedy Algorithms", "group": "17", "shape": "ellipse", "description": "Greedy Algorithms: A class of algorithms that make locally optimal choices at each step with the hope of finding a global optimum solution."}, {"id": "17.1.3.4", "label": "Huffman Codes", "group": "17", "shape": "square", "description": "Huffman Codes: A method of data compression that assigns variable-length codes to input characters, with shorter codes assigned to more frequently occurring characters."}, {"id": "17.2", "label": "Graph Algorithms", "group": "17", "shape": "box", "description": "Graph Algorithms: Graph algorithms are a fundamental part of computer science, focusing on analyzing and manipulating graphs, which consist of nodes (vertices) connected by edges."}, {"id": "17.2.1", "label": "Spanning trees", "group": "17", "shape": "ellipse", "description": "Spanning trees: A subgraph of a graph that includes all the vertices of the original graph with the minimum possible number of edges."}, {"id": "17.2.1.1", "label": "Kruskal\u2019s algorithm", "group": "17", "shape": "square", "description": "Kruskal\u2019s algorithm: A greedy algorithm for finding the minimum spanning tree (MST) of a connected, weighted graph."}, {"id": "17.2.1.2", "label": "Jarn\u00edk\u2019s algorithm", "group": "17", "shape": "square", "description": "Jarn\u00edk\u2019s algorithm: Another greedy algorithm for finding the minimum spanning tree (MST) of a connected, weighted graph."}, {"id": "17.2.4", "label": "Graph Applications", "group": "17", "shape": "ellipse", "description": "Graph Applications: "}, {"id": "17.3", "label": "Linear Programming", "group": "17", "shape": "box", "description": "Linear Programming: "}, {"id": "17.3.1", "label": "LP Introduction", "group": "17", "shape": "ellipse", "description": "LP Introduction: Introduction to linear programming, a method for optimizing a linear objective function subject to linear equality and inequality constraints."}], "edges": [{"from": "1", "to": "1.1", "title": ""}, {"from": "17", "to": "17.1", "title": ""}, {"from": "1.1", "to": "1.1.2", "title": ""}, {"from": "17.1.1", "to": "17.1.1.2", "title": ""}, {"from": "17.1", "to": "17.1.1", "title": ""}, {"from": "1.1", "to": "1.1.6", "title": ""}, {"from": "17.1.1", "to": "17.1.1.1", "title": ""}, {"from": "17.1.1.2", "to": "17.1.1.2.2", "title": ""}, {"from": "1.1", "to": "1.1.7", "title": ""}, {"from": "17.1", "to": "17.1.2", "title": ""}, {"from": "1.1", "to": "1.1.8", "title": ""}, {"from": "1.1", "to": "1.1.9", "title": ""}, {"from": "17.1", "to": "17.1.3", "title": ""}, {"from": "1.1", "to": "1.1.14", "title": ""}, {"from": "1.2", "to": "1.2.3", "title": ""}, {"from": "1", "to": "1.2", "title": ""}, {"from": "1.3.2", "to": "1.3.2.1", "title": ""}, {"from": "1.3", "to": "1.3.2", "title": ""}, {"from": "1", "to": "1.3", "title": ""}, {"from": "17.1.1.1", "to": "17.1.1.1.1", "title": ""}, {"from": "1.3", "to": "1.3.5", "title": ""}, {"from": "17", "to": "17.2", "title": ""}, {"from": "17.2", "to": "17.2.4", "title": ""}, {"from": "1.3.5", "to": "1.3.5.4", "title": ""}, {"from": "17.2", "to": "17.2.1", "title": ""}, {"from": "17.2.1", "to": "17.2.1.1", "title": ""}, {"from": "17.2.1", "to": "17.2.1.2", "title": ""}, {"from": "1.3.13", "to": "1.3.13.3", "title": ""}, {"from": "1.3", "to": "1.3.13", "title": ""}, {"from": "17.1.3", "to": "17.1.3.4", "title": ""}, {"from": "1.3", "to": "1.3.14", "title": ""}, {"from": "17.1.1.1", "to": "17.1.1.1.3", "title": ""}, {"from": "1.3.14", "to": "1.3.14.2", "title": ""}, {"from": "1.3.15", "to": "1.3.15.1", "title": ""}, {"from": "1.3", "to": "1.3.15", "title": ""}, {"from": "17.1.1.1", "to": "17.1.1.1.4", "title": ""}, {"from": "1.3", "to": "1.3.20", "title": ""}, {"from": "17", "to": "17.3", "title": ""}, {"from": "17.3", "to": "17.3.1", "title": ""}, {"from": "1.1", "to": "17.1", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.1.2", "to": "17.1.1.2", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.1.6", "to": "17.1.1.1", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.1.6", "to": "17.1.1.2.2", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.1.7", "to": "17.1.1", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.1.7", "to": "17.1.1.1", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.1.7", "to": "17.1.1.2.2", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.1.7", "to": "17.1.2", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.1.8", "to": "17.1.2", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.1.9", "to": "17.1.3", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.1.14", "to": "17.1.1", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.1.14", "to": "17.1.1.2.2", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.2.3", "to": "17.1.1.2.2", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.3.2.1", "to": "17.1.1.1.1", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.3.5", "to": "17.2", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.3.5", "to": "17.2.4", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.3.5.4", "to": "17.2.1", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.3.5.4", "to": "17.2.1.1", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.3.5.4", "to": "17.2.1.2", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.3.13.3", "to": "17.1.3.4", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.3.14", "to": "17.1.1.1.3", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.3.14.2", "to": "17.1.1.1.3", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.3.15.1", "to": "17.1.1.1.4", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.3.20", "to": "17.3", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}, {"from": "1.3.20", "to": "17.3.1", "title": "", "length": 900, "color": "grey", "width": 1, "shadow": false, "dashes": true}], "courseId": ["1", "17"]}